#!/bin/bash
#
# sboports - An simple shell-based ports-like manager for SlackBuilds.org scripts.
# Copyright (C) 2025 Rogério Girão
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Project Page: https://codeberg.org/rgcastrof/sboports
# Rogério Girão rogeriogirao1@proton.me
#
NAME=$(basename "$0")
VERSION=0.11.11
LOCAL_DIR="/var/lib"
REPO_NAME="slackbuilds"
REPO_DIR="$LOCAL_DIR/$REPO_NAME"
REPO_URL="git://git.slackbuilds.org/slackbuilds.git"
PKG_NAME=$(basename $(pwd))

	pkg_dir=$(sniff "$REPO_DIR" -t d "$pkg")
	if [ -z "$pkg_dir" ]; then
		echo "Package $pkg not found."
		exit 1
	fi
}

is_newer_version() {
	local local_version="$1"
	local repo_version="$2"
	local latest=$(printf "%s\n%s" "$local_version" "$repo_version" | sort -V | tail -n1)

	if [ "$latest" = "$repo_version" ] && [ "$local_version" != "$repo_version" ]; then
		return 0
	else
		return 1
	fi
}

check_args() {
	local args="$1"

	if [ "$args" -eq 0 ]; then
		echo "Error: You need to pass at least one argument."
		echo
		exit 1
	fi
}

show_pkg_status() {
	local -n installed_ref=$1
	local pkg="$2"

	if [ ! -z $(printf "%s\n" "${installed_ref[@]}" | grep -w "$pkg") ]; then
		echo "[ installed ] - $pkg"
	else
		echo "[uninstalled] - $pkg"
	fi
}

process_pkg() {
	local operation=$1
	shift
	local pkgs="$@"

	check_args $#
	for pkg in $pkgs; do
		$operation "$pkg"
	done
}

update_repo() {
	if [ ! -d "$REPO_DIR/.git" ]; then
		echo "Cloning repository, this may take a while..."
		mkdir -p "$REPO_DIR"
		if ! git clone "$REPO_URL" "$REPO_DIR"; then
			echo "Failed to clone repository."
			exit 1
		fi
		echo "Clone completed."
	else
		old=$(git --git-dir="$REPO_DIR/.git" --work-tree="$REPO_DIR" rev-parse HEAD)

		echo "Synchronizing SlackBuilds repository..."

		# clean the changes made in the local repo before updating
		git --git-dir="$REPO_DIR/.git" --work-tree="$REPO_DIR" reset --hard HEAD

		# pull updates
		if ! git --git-dir="$REPO_DIR/.git" --work-tree="$REPO_DIR" pull; then
			echo "Error: Failed to synchronize the repository."
			exit 1
		fi

		new=$(git --git-dir="$REPO_DIR/.git" --work-tree="$REPO_DIR" rev-parse HEAD)
		if [ "$old" != "$new" ]; then
			read -p "View the ChangeLog[y/N]? " answer
			if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
				less "$REPO_DIR/ChangeLog.txt"
			fi
		fi
		echo "Done."
	fi
}

search_pkg() {
	local pkg="$1"

	if [ -z $pkg ]; then
		echo "Error: you need to specify a name"
		exit 1
	fi

	names_match=$(sniff "$REPO_DIR" -p -t d "$pkg")
	if [ -z "$names_match" ]; then
		echo "Package $pkg not found"
	else
		echo "Searching for $pkg in the local SlackBuilds repository..."
		echo
		echo "List of all packages with name matching \"$pkg\"."
		echo
		for pkg_dir in $names_match; do
			pkg_name=$(basename "$pkg_dir")
			version=$(grep "VERSION" "$pkg_dir/$pkg_name.info" | cut -d '"' -f2)
			pkg_full="$pkg_name-$version"
			show_pkg_status INSTALLED "$pkg_full"
		done
	fi
}

check_source() {
	for ext in $EXTS; do
		source=$(sniff -p -t f "$pkg_dir" "$ext")
		if [ ! -z "$source" ]; then
			return 0
		fi
	done
	return 1
}

build_pkg() {
	local pkg="$1"
	check_dir "$pkg"
	urls=""
	src=()

	if check_source; then
		chmod +x "$pkg_dir/$pkg.SlackBuild" && "$pkg_dir/$pkg.SlackBuild"
		return
	fi
	
	# Extract source urls from the .info file
	for ext in $EXTS; do
		download=$(grep "$ext" "$pkg_dir/$pkg.info")
		if [ ! -z "$download" ]; then
			urls=$(echo "$download" | sed -E 's/^DOWNLOAD[^=]*=//' | tr -d '"' | tr -d '\\' | sed 's/^[[:space:]]*//')
		fi
	done

	# Download source files
	for url in $urls; do
		echo
		echo "Downloading source from: $url to directory: $pkg_dir..."
		echo
		if wget -P "$pkg_dir" "$url"; then
			echo
			echo "Download completed successfully"
			echo
		else
			echo
			echo "Error: Failed to download source file"
			echo
			exit 1
		fi
		file="$pkg_dir/$(basename "$url")"
		src+=("$file")
	done

	# Extract MD5 hashes from the .info file
	mapfile -t MD5SUM < <(grep -oE '[[:xdigit:]]{32}' "$pkg_dir/$pkg.info")

	# Verify integrity of downloaded files
	for i in "${!SRC[@]}"; do
		src=$(md5sum "${SRC[$i]}" | awk '{print $1}')
		echo "Verifying MD5 checksum for: $(basename ${SRC[$i]})..."
		if [ "$src" = "${MD5SUM[$i]}" ]; then
			echo "Checksum OK."
			echo
		else
			echo "Error: Checksum mismatch!"
			exit 1
		fi
	done

	chmod +x "$pkg_dir/$pkg.SlackBuild" && "$pkg_dir/$pkg.SlackBuild"
}

install_pkg() {
	local pkg="$1"

	if ! build_pkg "$pkg"; then
		echo "Error: failed to install package"
		exit 1
	fi

	build_path=$(sniff -p -t f -d 0 /tmp/ "$pkg" | sort -V | tail -n1)
	if [ -z "$build_path" ]; then
		echo "Error: package not found in /tmp"
		exit 1
	fi
	/sbin/upgradepkg --reinstall --install-new "$build_path"
	echo "Done upgrading/installing package."
}

remove_pkg() {
	local pkg="$1"
	/sbin/removepkg "$pkg"
}

update_pkgs() {
	echo "Checking for potential updates..."
	echo
	dif_found=0

	for i in ${!INSTALLED[@]}; do
		pkg=$(basename "${INSTALLED[$i]}")
		name=$(echo "$pkg" | sed -E 's/-[^-]+-[^-]+-[^-]+$//')
		local_version=$(echo "$pkg" | sed -E 's/^.*-([^-]+)-[^-]+-[^-]+$/\1/')

		repo_path=$(sniff "$REPO_DIR" -t d "$name" | head -n1)
		repo_version=$(grep "VERSION=" "$repo_path/$name.info" | cut -d '"' -f2)
		if [ "$local_version" != "$repo_version" ]; then
			dif_found=1

			if is_newer_version "$local_version" "$repo_version"; then
				echo
				echo "$name:	package is outdated: installed=$local_version | repo=$repo_version"
				echo
			else
				echo
				echo "$name:	package is newer than the repository: installed=$local_version | repo=$repo_version"
				echo
			fi
		fi
	done

	if [ "$dif_found" -eq 0 ]; then
		echo "All packages are up to date!"
	fi
}

list_deps() {
	local pkg="$1"
	check_dir "$pkg"

	deps_list=$(grep "REQUIRE" "$pkg_dir/$pkg.info" | cut -d '"' -f2)
	if [ -z "$deps_list" ]; then
		echo "No dependencies required for $pkg."
	else
		echo "List dependencies required for \"$pkg\":"
		echo
		for dep in $deps_list; do
			show_pkg_status INSTALLED "$dep"
		done
	fi
}

list_installed() {
	less <<EOF
List of installed SBo packages:

$INSTALLED
EOF
}

show_info() {
	local pkg="$1"
	check_dir "$pkg"
	readme=$(cat "$pkg_dir/README" 2>/dev/null)
	info=$(cat "$pkg_dir/$pkg.info" 2>/dev/null)
	slackbuild=$(cat "$pkg_dir/$pkg.SlackBuild" 2>/dev/null)

	less <<EOF
+--------+
| README |
+--------+

$readme

+------+
| INFO |
+------+

$info

+------------+
| SLACKBUILD |
+------------+

$slackbuild

EOF

}

get_queue_file() {
	if [ -z "$1" ]; then
		queue_file="$QUEUE_DIR/current.lst"
	else
		queue_file=$(sniff -t f -p "$QUEUE_DIR" "$1")
	fi

	if [ ! -f "$queue_file" ]; then
		echo "Error: no existing queue"
		exit 1
	fi
}

queue_add() {
	local pkgs=("$@")

	if [ ! -d "$QUEUE_DIR" ]; then
		mkdir -p "$QUEUE_DIR"
	fi

	for pkg in "${pkgs[@]}"; do
		echo "$pkg" >> "$QUEUE_DIR/current.lst"
	done

}

queue_run() {
	get_queue_file "$1"

	queue=$(cat "$queue_file")
	process_pkg install_pkg "$queue"
	queue_name=$(basename "$queue_file")
	if [ "$queue_name" == "current.lst" ]; then
		read -p "Do you want to save this queue[y/N]? " answer
		if [ "$answer" == "y" ] || [ "$answer" == "Y" ]; then
			if cat "$queue_file" > "$QUEUE_DIR/$(tail -n1 $queue_file).lst"; then
				echo "Queue saved successfully"
			fi
		fi
		rm "$queue_file"
	fi
}

queue_show() {
	queues=$(ls /var/lib/sbotool/queues/)
	if [ -z "$queues" ]; then
		echo "Failed, no existing queues."
		exit 1
	else
		echo "List of saved queues:"
		echo
		for queue in "$queues"; do
			echo "$queue"
		done
	fi
}

queue_list() {
	for arg in "$@"; do
		get_queue_file "$arg"
		if [ ! -z "$queue_file" ]; then
			echo "Current packages added in queue \"$arg\":"
			pkg_list=$(cat "$queue_file")
			for pkg in $pkg_list; do
				show_pkg_status INSTALLED "$pkg"
			done
		fi
		echo
	done
}

queue_rm() {
	for arg in "$@"; do
		get_queue_file "$arg"
		if [ ! -z "$queue_file" ] && [ -f "$queue_file" ]; then
			if rm "$queue_file"; then
				echo "queue $(basename $queue_file) removed successfully."
			else
				echo "Failed to remove the queue."
			fi
		fi
	done
}

queue_args() {
	local sub_cmd="$1"
	shift 2
	local pkgs="$@"

	case "$sub_cmd" in
		add)
			queue_add "$@"
			;;
		run)
			queue_run "$@"
			;;
		list)
			queue_list "$@"
			;;
		show)
			queue_show
			;;
		rm)
			queue_rm "$@"
			;;
		*)
			usage
			;;
	esac
}

show_changelog() {
	if ! less "$REPO_DIR/ChangeLog.txt"; then
		echo "Error: ChangeLog file not found."
	fi
}

usage() {
	cat <<EOF
$NAME - version $VERSION

Usage:
       $NAME {sync|update|list}
       $NAME {build|install|remove|search|deps} [PACKAGE]
       $NAME info [PACKAGE]
       $NAME queue {add|run|list|show|clear} [PACKAGE|QUEUE]
       $NAME {changelog|help}

For more info, run: $NAME help
EOF
}

show_help() {
	cat <<EOF
Usage: $NAME <command> [<arg>...]

List of $NAME commands:

Synchronize and check for updates:
	sync                        Clone or update the local slackbuilds repository.
	update                      Check if installed SBo packages differ from the local SlackBuilds repo.

Work with packages:
	search  <name>              Search for packages matching the given name.
	build   [<package>...]      Download, verify, and build the specified package(s).
	list                        List all installed SBo packages.
	install [<package>...]      Build and install the specified package(s).
	remove  [<package>...]      Remove the specified package(s).
	deps    [<package>...]      List all dependencies requeired by the specified package(s)
	info    <package>           Show the README, .info file, and SlackBuild script for the package.

Work with queues:
	queue add  [<package>...]   Add the specified package.
	queue run  <queue>          Process the specified queue and install the package.
	queue list [<queue>...]     List the packages added in the specified queue(s).
	queue rm   [<queue>...]     Delete the specified queue(s).
	queue show                  List all saved queues.

Show information:
	changelog                   Open the ChangeLog file for read.
	help                        Print this help message.
EOF
}

case "$1" in
	sync)
		update_repo
		;;
	search)
		search_pkg "$2"
		;;
	update)
		update_pkgs
		;;
	build)
		shift && process_pkg build_pkg "$@"
		;;
	install)
		shift && process_pkg install_pkg "$@"
		;;
	remove)
		shift && process_pkg remove_pkg "$@"
		;;
	deps)
		shift && process_pkg list_deps "$@"
		;;
	queue)
		shift
		queue_args "$1" "$@"
		;;
	list)
		list_installed
		;;
	info)
		show_info "$2"
		;;
	changelog)
		show_changelog
		;;
	help)
		show_help
		;;
	*)
		usage
		exit 1
		;;
esac
